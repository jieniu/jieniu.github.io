(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{399:function(o,e,a){"use strict";a.r(e);var t=a(45),l=Object(t.a)({},(function(){var o=this,e=o.$createElement,a=o._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[a("h1",{attrs:{id:"避免在构造函数或析构函数中调用虚函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免在构造函数或析构函数中调用虚函数"}},[o._v("#")]),o._v(" 避免在构造函数或析构函数中调用虚函数")]),o._v(" "),a("p",[o._v("我们先来看下下面程序")]),o._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[o._v('#include <iostream>\nusing namespace std;\n                                            \nclass Dog {\npublic:\n    Dog () { cout << "I\'m a dog" << endl; }\n    virtual ~Dog () { cout << "destroy a dog" << endl; }\n\n\tvoid bark() { cout << "dog bark" << endl; }\n    void seeDog() { bark(); }\n};\n\nclass YellowDog : public Dog {\npublic:\n    YellowDog() { cout << "I\'m a yellow dog" << endl; }\n    virtual ~YellowDog() { cout << "destroy a yellow dog" << endl;}\n\n    void bark() { cout << "yellow dog bark" << endl; }\n};\n\n\nint main() {\n    YellowDog yd = YellowDog();\n    yd.seeDog();\n\n    return 0;\n}\n')])])]),a("p",[o._v("运行上述程序后，得到以下输出：")]),o._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[o._v("I'm a dog\nI'm a yellow dog\ndog bark\ndestroy a yellow dog\ndestroy a dog\n")])])]),a("p",[o._v("可以看到在创建 "),a("code",[o._v("YellowDog")]),o._v(" 对象时，首先会调用基类的构造函数，而且虽然是 "),a("code",[o._v("YellowDog")]),o._v(" 调用的 "),a("code",[o._v("seeDog")]),o._v("，但执行的却是 "),a("code",[o._v("Dog::bark")]),o._v("，此时，如果你想要调用 "),a("code",[o._v("YellowDog::bark")]),o._v("，你需要把基类 "),a("code",[o._v("Dog")]),o._v(" 中的 "),a("code",[o._v("bark")]),o._v(" 声明为 "),a("code",[o._v("virtual")]),o._v(" 类型，如下：")]),o._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[o._v('\tvirtual void bark() { cout << "dog bark" << endl; }\n')])])]),a("p",[o._v("同时，为了更好的可读性，建议你也将子类中的继承自基类的虚函数也显示的声明为 "),a("code",[o._v("virtual")]),o._v("，此时你再运行上面的程序后，就可以看到 "),a("code",[o._v("YellowDog::bark")]),o._v(" 被调用了，这就是 C++ 中的多态或动态绑定。")]),o._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[o._v("I'm a dog\nI'm a yellow dog\nyellow dog bark\ndestroy a yellow dog\ndestroy a dog\n")])])]),a("p",[o._v("下面，我们做点小改动，故意让 C++ 中的动态绑定失效，我们把 "),a("code",[o._v("seeDog()")]),o._v(" 中的 "),a("code",[o._v("bark()")]),o._v(" 挪到 "),a("code",[o._v("Dog")]),o._v(" 的构造函数中，看下会出现什么情况")]),o._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[o._v('\t// ...\n    Dog () { cout << "I\'m a dog" << endl; bark(); }\n\t// ...\n')])])]),a("p",[o._v("此时输出变成了")]),o._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[o._v("I'm a dog\ndog bark\nI'm a yellow dog\ndestroy a yellow dog\ndestroy a dog\n")])])]),a("p",[o._v("可以看到虽然声明了虚函数，但却没有进行动态绑定，原因在于"),a("strong",[o._v("在调用 "),a("code",[o._v("Dog")]),o._v(" 的构造函数时，"),a("code",[o._v("YellowDog")]),o._v(" 对象还没有被构造完成，对一个不存在的对象调用其成员函数是非常危险的")]),o._v("，所以编译器在这里选择了调用 "),a("code",[o._v("Dog::bark")]),o._v("，而不是 "),a("code",[o._v("YellowDog::bark")]),o._v("，同时要注意的是，"),a("strong",[o._v("在构造函数中尽可能的只做最简单的初始化操作，避免复杂的函数调用。")])]),o._v(" "),a("p",[o._v("现在我们把 "),a("code",[o._v("bark()")]),o._v(" 放在 "),a("code",[o._v("Dog")]),o._v(" 中的析构函数中，看下会发生什么情况")]),o._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[o._v('    // ...\n\tDog () { cout << "I\'m a dog" << endl;  }\n    virtual ~Dog () { cout << "destroy a dog" << endl; bark();}\n\t// ...\n')])])]),a("p",[o._v("输出如下")]),o._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[o._v("I"),a("span",{pre:!0,attrs:{class:"token string"}},[o._v("'m a dog\nI'")]),o._v("m a yellow dog\ndestroy a yellow dog\ndestroy a dog\ndog bark\n")])])]),a("p",[o._v("再一次，多态的特性没有生效，原因在于在析构 "),a("code",[o._v("YellowDog")]),o._v(" 的对象时，先调用 "),a("code",[o._v("YellowDog")]),o._v(" 的析构函数，即在调用 "),a("code",[o._v("bark")]),o._v(" 时，"),a("code",[o._v("YellowDog")]),o._v(" 部分的数据已经被清理，此时再调用该对象的虚函数也是非常危险的，所以为了安全起见，编译器又一次选择了调用基类的 "),a("code",[o._v("bark")]),o._v("。")]),o._v(" "),a("p",[o._v("以上，我们学到了一条宝贵的经验：")]),o._v(" "),a("blockquote",[a("p",[o._v("不要在构造函数或析构函数中调用虚函数")])]),o._v(" "),a("p",[o._v("参考：https://www.youtube.com/watch?v=mTE5jaXaOuE&t=0s&index=9&list=PLE28375D4AC946CC3")])])}),[],!1,null,null,null);e.default=l.exports}}]);