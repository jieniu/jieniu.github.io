(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{387:function(r,l,a){"use strict";a.r(l);var e=a(45),t=Object(e.a)({},(function(){var r=this,l=r.$createElement,a=r._self._c||l;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"复制操作符怎么写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制操作符怎么写"}},[r._v("#")]),r._v(" 复制操作符怎么写")]),r._v(" "),a("p",[r._v("C++ 中的操作符重载可以让我们的代码更符合人们的阅读习惯，而 "),a("code",[r._v("operator=")]),r._v(" 赋值操作符又是最常被重载的操作符。本篇主要谈到我们在写 "),a("code",[r._v("operator=")]),r._v(" 时可能会遇到的复制相同对象的问题，及我们该如何解决它。")]),r._v(" "),a("p",[r._v("对于「复制自己」，你肯定不会写这样的代码")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("Dog a;\na = a;\n")])])]),a("p",[r._v("但你可能会写这样的代码")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("dogs[i] = dogs[j];\n")])])]),a("p",[r._v("而当 "),a("code",[r._v("i")]),r._v(" 和 "),a("code",[r._v("j")]),r._v(" 相等时，你便无意间写出了「复制自己」的代码，但到底「复制自己」会出现什么问题呢？先来看下下面这段代码：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("class Collar{};\nclass Dog {\n    Collar* pCollar;\n    \n    Dog& operator=(const Dog& rhs) {\n        delete pCollar;\n        pCollar = new Collar(*rhs.pCollar);\n        return *this;\n    }\n};\n")])])]),a("p",[r._v("上面这段赋值操作符的实现，首先就把指针 "),a("code",[r._v("pCollar")]),r._v(" 给释放了，如果传入的对象就是自己，那么 "),a("code",[r._v("pCollar = new Collar(*rhs.pCollar)")]),r._v(" 这一行中的 "),a("code",[r._v("rhs.pCollar")]),r._v(" 就会引用一个被释放的指针，这会对程序造成灾难性的结果。")]),r._v(" "),a("p",[r._v("于是，为避免「复制自己」的问题，我们可以在 "),a("code",[r._v("delete")]),r._v(" 之前加一个条件判断，如下")]),r._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("// ...\n    Dog& operator=(const Dog& rhs) {\n        if (this == &rhs) {\n            return *this;\n        }\n        \n        delete pCollar;\n        pCollar = new Collar(*rhs.pCollar);\n        return *this;\n    }\n// ... \n")])])]),a("p",[r._v("但这还没完，这里还有一个漏洞，如果 "),a("code",[r._v("new Collar(*rhs.pCollar)")]),r._v(" 抛出异常，则该对象的 "),a("code",[r._v("pCollar")]),r._v(" 由于被释放了，而变成了一个”野指针“，这也会给程序带来无法预期的结果。所以更为安全的写法是这样的：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("// ...\n    Dog& operator=(const Dog& rhs) {\n        if (this == &rhs) {\n            return *this;\n        }\n        \n        Collar* pOriginCollar = pCollar;\n        pCollar = new Collar(*rhs.pCollar);\n        delete pOriginCollar;\n        return *this;\n    }\n// ...\n")])])]),a("p",[r._v("可以看到，即便 "),a("code",[r._v("new Collar")]),r._v(" 抛出了异常，"),a("code",[r._v("pCollar")]),r._v(" 所指向的内容仍然不变。")]),r._v(" "),a("p",[r._v("此外，我们还有另外一种解决「复制自己」的方案，即面向对象中常用的委派（delegate），例如这里要复制的 "),a("code",[r._v("Collar")]),r._v(" 对象，不是在宿主 "),a("code",[r._v("Dog")]),r._v(" 对象中完成，而是把复制的动作委派给 "),a("code",[r._v("Collar")]),r._v("  的复制构造函数去完成，这样做的好处是各个类的代码各司其职，复杂度降低，更不易出错，如下：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("class Collar {\n    int price;\npublic:\n\tCollar &operator=(const Collar& rhs) {\n    \tif (this == &rhs) {\n        \treturn *this;\n    \t}\n    \tprice = rhs.price;\n    \treturn *this;\n\t}\n};\n\nclass Dog {\n    Collar* pCollar;\n    Dog& operator=(const Dog& rhs) {\n        *pCollar = *rhs.pCollar; // member by member copy of Collars\n        return *this;\n    }\n};\n")])])]),a("p",[r._v("以上，请记住一点")]),r._v(" "),a("blockquote",[a("p",[r._v("在写复制操作符时，要避免复制自己。")])]),r._v(" "),a("p",[r._v("参考：")]),r._v(" "),a("p",[r._v("https://www.youtube.com/watch?v=4qhz7E59QBs&index=9&list=PLE28375D4AC946CC3")])])}),[],!1,null,null,null);l.default=t.exports}}]);