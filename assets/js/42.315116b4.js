(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{396:function(n,e,t){"use strict";t.r(e);var a=t(45),c=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"为什么不要使用全局变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么不要使用全局变量"}},[n._v("#")]),n._v(" 为什么不要使用全局变量")]),n._v(" "),t("p",[n._v("在写程序时，我们都知道一条规范：不要使用全局变量。至于为什么，有可能是因为它会污染命名空间，也有可能是因为它会造成程序的不确定性，本文主要使用一个例子，来说明全局变量是如何让程序变得不确定的。")]),n._v(" "),t("p",[n._v("我们先定义两个类，一个 "),t("code",[n._v("Cat")]),n._v("，一个 "),t("code",[n._v("Dog")]),n._v("，如下是 "),t("code",[n._v("cat.h")]),n._v(" 和 "),t("code",[n._v("cat.cc")]),n._v(" 文件")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// cat.h\n#include <iostream>\nusing namespace std;\n\nclass Cat;\nextern Cat c;\n\nclass Cat {\npublic:\n    Cat(char* name);\n    void meow();\nprivate:\n    char* _name;\n};\n\n// cat.cc\n#include "cat.h"\n#include "dog.h"\n\nCat c("mimi");\nCat::Cat(char* name) {\n    cout << "construct cat" << endl;\n    _name = name;\n}\n\nvoid Cat::meow() {\n    cout << "cat " << _name << " meow" << endl;\n}\n')])])]),t("p",[t("code",[n._v("Cat")]),n._v(" 类很简单，只有一个成员 "),t("code",[n._v("_name")]),n._v("，它是一个指针变量，且通过 "),t("code",[n._v("meow")]),n._v(" 方法把它打印到屏幕上，同时，我们还定义了一个全局变量 "),t("code",[n._v('Cat c("mimi");')]),n._v("，同样的，"),t("code",[n._v("Dog")]),n._v(" 类的定义也很简单，如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// dog.h\n#include <iostream>\nusing namespace std;\n\nclass Dog;\nextern Dog d;\n\nclass Dog {\npublic:\n    Dog(char* name);\n    void bark();\nprivate:\n    char* _name;\n};\n\n// dog.cc\n#include "dog.h"\n#include "cat.h"\n\nDog d("kobe");\nDog::Dog(char* name) {\n    cout << "construct dog" << endl;\n    _name = name;\n}                                                                   \n                                                                    \nvoid Dog::bark() {                                                  \n    cout << "dog " << _name << " bark" << endl;                     \n}\n')])])]),t("p",[n._v("我们给 "),t("code",[n._v("Dog")]),n._v(" 也定义了一个全局变量 "),t("code",[n._v('d("kobe");')]),n._v("，此时，我们修改一下 "),t("code",[n._v("Cat")]),n._v(" 的构造函数，在里面引用全局变量 "),t("code",[n._v("d")]),n._v("，看看会发生什么")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('Cat::Cat(char* name) {\n    cout << "construct cat" << endl;\n    _name = name;\n    d.bark();\n}\n')])])]),t("p",[n._v("编译运行前，别忘了我们的入口文件 "),t("code",[n._v("main.cc")]),n._v("，如下")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("int main() {\n    return 0;\n}\n")])])]),t("p",[n._v("现在，我们将其进行编译运行")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("...\ng++ -o main main.o cat.o dog.o -std=c++11  // 编译时的输出，说明了链接顺序\n$ ./main\nconstruct cat\n// [1]    50759 segmentation fault  ./main \n")])])]),t("p",[n._v("可以看到程序崩溃了，崩溃原因是我们刚才在 "),t("code",[n._v("Cat")]),n._v(" 构造函数中增加的一行调用全局变量的代码，因为在调用这行代码时，全局变量 "),t("code",[n._v("d")]),n._v(" （实际上是 "),t("code",[n._v("d._name")]),n._v(" ）还没初始化。")]),n._v(" "),t("p",[n._v("而全局变量的初始化顺序是由编译器决定的，所以如果我们的全局变量间又有互相依赖的话，就很容易造成程序崩溃。")]),n._v(" "),t("p",[n._v("避免使用全局变量的方法也有很多，其中最广泛的应数 Singleton 模式了，针对上面的代码，我们可以定义一个 "),t("code",[n._v("Singleton")]),n._v(" 类，其中包含 "),t("code",[n._v("Cat")]),n._v(" 和 "),t("code",[n._v("Dog")]),n._v(" 的静态指针，如下")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// singleton.h\nclass Cat;\nclass Dog;\nclass Singleton {\n    static Dog* pd;\n    static Cat* pc;\npublic:\n    ~Singleton();\n\n    static Dog* getDog();\n    static Cat* getCat();\n};\n")])])]),t("p",[n._v("与此同时，我们还声明了两个静态方法，用来获取 "),t("code",[n._v("Dog")]),n._v("  或 "),t("code",[n._v("Cat")]),n._v(" 的指针，并且，我们希望 "),t("code",[n._v("Dog")]),n._v(" 和 "),t("code",[n._v("Cat")]),n._v(" 是以 lazy 的方式进行初始化的，即下面的 singleton.cc 文件的实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// singleton.cc\n#include "singleton.h"\n#include "dog.h"\n#include "cat.h"\n\nDog* Singleton::pd = 0;\nCat* Singleton::pc = 0;\nSingleton::~Singleton() {\n    delete pd;\n    delete pc;\n    pd = 0;\n    pc = 0;\n}\nDog* Singleton::getDog() { \n    if (pd == 0) {\n        pd = new Dog("kobe");  \n    }\n    return pd;\n}\nCat* Singleton::getCat() {\n    if (pc == 0) {\n        pc = new Cat("mimi");\n    }\n    return pc;\n}\n')])])]),t("p",[n._v("可以看到初始化 "),t("code",[n._v("Cat")]),n._v(" 和 "),t("code",[n._v("Dog")]),n._v(" 的时机是在第一次调用 "),t("code",[n._v("getCat")]),n._v(" 和 "),t("code",[n._v("getDog")]),n._v(" 时。现在你就可以删掉程序中的全局变量了，当你需要使用 "),t("code",[n._v("Cat")]),n._v(" 对象或 "),t("code",[n._v("Dog")]),n._v(" 对象时，直接调用 "),t("code",[n._v("Singleton::getCat()")]),n._v(" 或 "),t("code",[n._v("Singleton::getDog()")]),n._v(" 即可。")]),n._v(" "),t("p",[n._v("参考：")]),n._v(" "),t("ul",[t("li",[n._v("https://www.youtube.com/watch?v=hE77OSTE2J0&t=87s")])])])}),[],!1,null,null,null);e.default=c.exports}}]);