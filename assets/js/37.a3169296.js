(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{390:function(e,t,n){"use strict";n.r(t);var a=n(45),l=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"禁止成员函数-disallow-functions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#禁止成员函数-disallow-functions"}},[e._v("#")]),e._v(" 禁止成员函数（disallow functions）")]),e._v(" "),n("p",[e._v("本文将介绍禁止编译器自动生成某些函数的2种方法，及在某些场景下（例如嵌入式编程中），禁止析构函数给程序带来的好处。")]),e._v(" "),n("p",[e._v("还记得如何禁止默认构造函数吗，即定义一个带参数的构造函数即可，如下面的代码将会编译失败")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class OpenFile {\npublic:\n    // 定义一个带参构造函数\n\tOpenFile(string filename) {/*...*/}\n};\n\nint main() {\n    OpenFile f; // error: no matching constructor for initialization of 'OpenFile'\n}\n")])])]),n("p",[e._v("除此之外，我们还可以显示的禁止某些函数的定义")]),e._v(" "),n("ol",[n("li",[e._v("在 C++ 03 中，我们可以将这些函数声明在 "),n("code",[e._v("private")]),e._v(" 作用域中，且不定义它们")]),e._v(" "),n("li",[e._v("在 C++ 11 中，提供了 "),n("code",[e._v("delete")]),e._v(" 关键字来实现此功能")])]),e._v(" "),n("p",[e._v("假设你有一个文件类 "),n("code",[e._v("OpenFile")]),e._v("，你不希望这类对象互相复制，因为这会把文件写乱，此时你可以禁止该类的复制构造函数和赋值操作符，在 C++ 03 中，你可以这样做")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class OpenFile {\nprivate:\n\tOpenFile(OpenFile& rhs);\n\tOpenFile& operator=(const OpenFile& rhs);\n}；\n")])])]),n("p",[e._v("C++ 11中是这样的")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class OpenFile {\npublic:\n\tOpenFile(OpenFile& rhs) = delete;\n\tOpenFile& operator=(const OpenFile& rhs) = delete;\n}；\n")])])]),n("p",[e._v("在某些情况下，如果你不希望继承来自基类的函数，你也可以这样显示声明")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Base {\npublic:\n\tvoid foo();\n};\n\nclass Derived : public Base {\npublic:\n\tvoid foo() = delete; // 不继承 foo()\n};\n\nint main() {\n    Derived d;\n    d.foo(); // error: attempt to use a deleted function\n}\n")])])]),n("p",[n("strong",[e._v("禁止析构函数")])]),e._v(" "),n("p",[e._v("在嵌入式编程中，由于栈空间比较小的原因，我们会避开将一些大对象存储在栈中，而选择将他们存放在堆中，栈中对象的特点是：当对象离开局部空间（函数或程序块），存储在栈中的对象会自动释放，对象的析构函数会被调用，此时，如果我们将对象的析构函数定义在 "),n("code",[e._v("private")]),e._v(" 域中，即禁止外部释放对象，就可以有效地保护对象不被存储在栈中。")]),e._v(" "),n("p",[e._v("当然，存储在堆中的对象还是要提供销毁功能的，你可以额外定义一个「自定义的析构函数」，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class BigBlock {\npublic:\n\tBigBlock();\n\tvoid destroyMe() {delete this;}\nprivate:\n\t~BigBlock() {/*...*/}\n};\n\nint main() {\n    BigBlock *b = new BigBlock();\n    b->destroyMe(); \n}\n")])])]),n("p",[e._v("总结，本文主要介绍了以下内容")]),e._v(" "),n("ol",[n("li",[e._v("C++ 11: f() = delete; 使用 "),n("code",[e._v("delete")]),e._v(" 关键字")]),e._v(" "),n("li",[e._v("C++ 03: 将函数声明在 "),n("code",[e._v("private")]),e._v(" 中，且不定义它")]),e._v(" "),n("li",[n("code",[e._v("private")]),e._v(" 析构函数: stay out of stack.")])]),e._v(" "),n("p",[e._v("参考：")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://www.youtube.com/watch?v=EL30-a2gblQ&t=0s&list=PLE28375D4AC946CC3&index=6",target:"_blank",rel:"noopener noreferrer"}},[e._v("Advanced C++: Disallow Functions"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=l.exports}}]);