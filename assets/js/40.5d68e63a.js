(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{393:function(s,t,e){"use strict";e.r(t);var n=e(45),c=Object(n.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"logic-constness-and-bitwise-constness"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#logic-constness-and-bitwise-constness"}},[s._v("#")]),s._v(" Logic constness And Bitwise constness")]),s._v(" "),e("h3",{attrs:{id:"什么是-logic-constness"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-logic-constness"}},[s._v("#")]),s._v(" 什么是 Logic constness")]),s._v(" "),e("p",[s._v("有以下类 "),e("code",[s._v("BigArray")]),s._v("，其成员 "),e("code",[s._v("vector<int> v;")]),s._v(" 是一个数组数据结构，为了让外部可以访问该数组，此类提供了一个 "),e("code",[s._v("getItem")]),s._v(" 接口，除此之外，为了计算外部访问数组的次数，该类还设置了一个计数器 "),e("code",[s._v("accessCounter")]),s._v(" ，可以看到用户每次调用 "),e("code",[s._v("getItem")]),s._v(" 接口，"),e("code",[s._v("accessCounter")]),s._v(" 就会自增，很明显，这里的成员 "),e("code",[s._v("v")]),s._v(" 是核心成员，而 "),e("code",[s._v("accessCounter")]),s._v(" 是非核心成员，我们希望接口 "),e("code",[s._v("getItem")]),s._v(" 不会修改核心成员，而不考虑非核心成员是否被修改，此时 "),e("code",[s._v("getItem")]),s._v(" 所具备的 "),e("code",[s._v("const")]),s._v(" 特性就被称为 "),e("strong",[s._v("logic constness")]),s._v("。")]),s._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class BigArray {\n    vector<int> v; \n    int accessCounter;\npublic:\n    int getItem(int index) const { // 因为bitwise constness，所以无法编译通过\n        accessCounter++;\n        return v[index];\n    }\n};\n")])])]),e("h3",{attrs:{id:"什么是-bitwise-constness"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-bitwise-constness"}},[s._v("#")]),s._v(" 什么是 Bitwise constness")]),s._v(" "),e("p",[s._v("但是，上面的代码不会通过编译，因为编译器不会考虑 logic constness ，于是就有了 "),e("strong",[s._v("bitwise constness")]),s._v(" 这个术语，可以理解为字面上的 const 属性。为了解决这种矛盾，可以把 "),e("code",[s._v("accessCounter")]),s._v(" 声明为 "),e("code",[s._v("mutable")]),s._v(" 的成员，即")]),s._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class BigArray {\n\t// ...\n    mutable int accessCounter; \n    // const_cast<BigArray*>(this)->accessCounter++; // 这样也行，但不建议这么做\n    // ...\n};\n")])])]),e("p",[s._v("此时编译器是可以通过编译的。")]),s._v(" "),e("p",[s._v("反过来，如果你的成员是指针类型，在函数中我们修改了指针所指的数据，此时编译器依然只会维护 bitwise constness，即便我们将这样的函数声明为 const，依然是没有问题的，例如")]),s._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class BigArray {\n    int* v2;\n\t// ...\n  \tvoid setV2Item(int index, int x) const {\n        v2[index] = x;\n  \t}\n};\n")])])]),e("p",[s._v("但逻辑上，这个函数不应该被声明为 const，所以这里最好把 const 关键字去掉。")]),s._v(" "),e("p",[e("strong",[s._v("结论")])]),s._v(" "),e("p",[s._v("logic constness 和 bitwise constness 的重要性排序：logic constness > bitwise constness")]),s._v(" "),e("p",[s._v("参考：https://www.youtube.com/watch?v=8A5AwX6XExw&index=4&list=PLE28375D4AC946CC3&t=0s")])])}),[],!1,null,null,null);t.default=c.exports}}]);