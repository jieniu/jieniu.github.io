(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{398:function(e,t,a){"use strict";a.r(t);var s=a(45),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"虚析构函数和智能指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚析构函数和智能指针"}},[e._v("#")]),e._v(" 虚析构函数和智能指针")]),e._v(" "),a("h2",{attrs:{id:"虚析构函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚析构函数"}},[e._v("#")]),e._v(" 虚析构函数")]),e._v(" "),a("p",[e._v("当我们想在程序中实现多态时，我们经常会这样做：")]),e._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('#include <iostream>\nusing namespace std;\nclass Dog {\npublic:\n  Dog() {}\n  ~Dog() { cout << "Dog destroy\\n";}\n};\n\nclass YellowDog : public Dog {\npublic:\n  YellowDog() {}\n  ~YellowDog() { cout << "YellowDog destroy\\n";}\n  static Dog* createDog() { return new YellowDog(); }\n};\n')])])]),a("p",[e._v("即用工厂类或工厂方法来创建具体的对象，而在运行时通过对基类（这里是Dog）的指针或引用来实现对不同子类（这里是YellowDog）的调用，这样我们就实现了「多态」。不过，上面代码是有问题的，你可以看下面代码的输出：")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("int main(int argc, char** argv) {\n  Dog* dog = YellowDog::createDog();\n  delete dog;\n  return 0;\n}\n----<output>----\nDog destroy\n")])])]),a("p",[e._v("从输出结果可以看出，"),a("code",[e._v("delete dog")]),e._v(" 时，只调用了基类的析构函数，而子类对象没有被析构，此时很可能会发生内存泄露，为了避免这种情况，我们需要在基类析构函数前加上 "),a("code",[e._v("virtual")]),e._v(" 关键字，如下")]),e._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('virtual ~Dog() { cout << "Dog destroy\\n"; }\n')])])]),a("p",[e._v("接着重新编译后再运行程序，便可以看到子类对象被如期析构了")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("----<output>----\nYellowDog destroy\nDog destroy\n")])])]),a("h2",{attrs:{id:"用智能指针-shared-ptr-实现动态析构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用智能指针-shared-ptr-实现动态析构"}},[e._v("#")]),e._v(" 用智能指针 shared_ptr 实现动态析构")]),e._v(" "),a("p",[e._v("从 C++ 11 起，通过 "),a("code",[e._v("shared_ptr")]),e._v(" 你同样可以实现动态析构，"),a("code",[e._v("shared_ptr")]),e._v(" 定义在头文件 "),a("code",[e._v("<memory>")]),e._v(" 中")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("template< class T > class shared_ptr;\n")])])]),a("p",[e._v("下面我们就来看下智能指针的版本")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('class Dog {\npublic:\n  Dog(){}\n  ~Dog() { cout << "Dog destructor" << endl; }\n};\n\nclass YellowDog : public Dog {\npublic:\n  YellowDog() {}\n  ~YellowDog() { cout << "YellowDog destructor" << endl; }\n\n  static shared_ptr<Dog> createDog() {\n      return shared_ptr<YellowDog>(new YellowDog());\n  }\n};\n\nint main() {\n    shared_ptr<Dog> p = YellowDog::createDog();\n    return 0;\n}\n')])])]),a("p",[e._v("从输出中可以看到虽然 "),a("code",[e._v("Dog")]),e._v(" 类中的析构函数没有声明 "),a("code",[e._v("virtual")]),e._v("，但 "),a("code",[e._v("YellowDog")]),e._v(" 的析构函数仍然被顺利调用了。")]),e._v(" "),a("p",[a("em",[e._v("注意："),a("code",[e._v("STL")]),e._v(" 中的所有类都没有 "),a("code",[e._v("virtual")]),e._v(" 析构函数，所以当你从 "),a("code",[e._v("STL")]),e._v(" 中派生子类时，要尽可能的使用 "),a("code",[e._v("shared_ptr")])]),e._v("。")]),e._v(" "),a("p",[e._v("参考：https://www.youtube.com/watch?v=ZiNGWHg5Z-o&index=6&list=PLE28375D4AC946CC3")])])}),[],!1,null,null,null);t.default=o.exports}}]);